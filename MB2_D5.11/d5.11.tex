\documentclass[11pt, a4paper, twoside]{montblanc2}
\usepackage[T1]{fontenc}
\usepackage{url}
\usepackage{color}
\usepackage{xspace}

\def\cmake{\textsc{CMake}\xspace}
\def\lua{\textsc{Lua}\xspace}
\def\dd{\textsc{DwarfDump}\xspace}
\def\elfutils{\textsc{ElfUtils}\xspace}

\begin{document}
\devnum{[5.11]}
\title{[MAQAO in BOAST]}
\version{[0.1]}
\deadline{[2017/01/16]}
\level{[PU]}
\nature{[O]}
\authors{Olivier Aumage (Inria) and Brice Videau (CNRS)}
\contributors{} % {Name (PARTNER), Name (PARTNER), Name (PARTNER)}
\reviewers{} % {Name (PARTNER), Name (PARTNER), }
\keywords{[analysis, autotuning, performance]}

\maketitle

\begin{changelog}
\change{0.1}{Initial version of D5.11}
\end{changelog}

\frontmatter

\begin{executive}
  \todo{executive summary}
\end{executive}

\section{Introduction}
\todo{intro}

\section{Context}
\todo{context}

\subsection{BOAST}
\begin{itemize}
  \item General presentation of BOAST
  \item Purpose, capabilities, usage
\end{itemize}

\subsection{MAQAO}
\begin{itemize}
  \item General presentation of MAQAO
  \item Purpose, capabilities, usage
\end{itemize}

\subsubsection{Presentation}
MAQAO, the Modular Assembly Quality Analyzer and Optimizer, is a performance analysis and processing 
tool working at the level of compiled, binary code. It was initially developed at the University of 
Versailles in France, and has been partially developed at Inria in Bordeaux as well since around 
2010. While primarily focused on Intel processors (x86-64, xeon phi, and even Itanium), it was 
ported on the ARM architecture as part of Mont-Blanc~2 task D5.3 work, and delivered as 
Deliverable~D5.4. The MAQAO tool presents itself as an extensible framework for binary code 
processing. It is a made of a C-language low-level core set of libraries and a high-level set of 
wrappers making the framework scriptable in the language \lua using the embedded interpretor. 

The core libraries of MAQAO enable the fundamental operations to disassemble a binary file, modify 
its assembly instructions (operation designated as 'patching'), and re-assemble the modified binary. 
Possible instruction modifications include moving/inserting/suppressing code blocks, inserting 
function calls, or operations designated as 'instrumentation' where some sets of instructions are 
both moved and modified such as a function call is made every time such instructions are called 
before executing the instrumented instructions themselves. Core services also include foundational 
capabilities such as building call graphs and control flow graphs from the disassembled binary 
functions.

A set of \lua-to-C wrapper routines implement the transition between the C~core and the Lua 
services. These routines enable to manipulate relevant assembly objects such as binary files, 
functions, basic instruction blocks, individual instructions, instruction operands, loops and 
labels. 

On top of those transitional routines, special-purpose processing modules can be implemented in Lua 
to perform high level operations such as analysis, tracing and hinting. In particular, tracing 
involves instrumenting every memory reference in the studied kernel with calls to the memory access 
accounting routine in the MAQAO Trace Library (MTL) which monitor every memory address referenced 
within the kernel routine during an execution, and generate a compressed trace of the memory 
references. The trace can then be further processed to output memory access patterns as human 
readable algebraic expressions.

\subsubsection{Usage}

The MAQAO framework version developed in Bordeaux is very much targeted at an experimented audience, 
and, as a note of warning, it may lack the user friendliness commonly found in mature academic and 
commercial programming tools. It is aimed at expert users desirous to dig further into the binary 
kernel code produced by their compiler, and build their own, custom analysis strategies.
This section presents MAQAO from a functional point-of-view, and specify usage for the most common
operations.

\paragraph{Requirements and Installation}

MAQAO's C language core mandatorily requires \cmake version~2.8.8 or above, a C compiling toolchain 
and Make. The \lua layers directly make use of the embedded \lua distribution. Moreover, MAQAO 
analysis scripts may leverage the command-line tool \dd to process debugging informations and 
symbols in compiled objects files when available, while \dd itself relies on the availability of an 
\elfutils distribution. Supported binary objects and executables to be processed by MAQAO must 
follow the ELF format specification and System V general ABI specification, and be generated for the 
ARM architecture, while optional debugging information must follow the DWARF-2 format. Support for 
ARM's Thumb instruction sets is limited to disassembly only.

Building MAQAO involves running \cmake followed by the \verb|make| command after untaring the 
distribution or checking it out from the development repository:

\begin{verbatim}
$ tar zxf maqao.tar.gz
$ cd MAQAO
$ mkdir build
$ cd build
$ cmake -DARCHS=arm -DSTRIP=false ..
$ make
\end{verbatim}

No install step is required. MAQAO's executable is produced in \verb|MAQAO/bin| and MAQAO's 
libraries are placed in the \verb|MAQAO/lib| directory. MAQAO's \verb|/bin| and \verb|/lib|
directories should be added to \verb|PATH| and \verb|LD_LIBRARY_PATH| environment variables 
respectively. Environment variable \verb|MAQAO| should be set to MAQAO's top directory for 
convenience, and is assumed to be set accordingly in the remainder of the document.

\paragraph{Disassemble}

\paragraph{Instrument}

\paragraph{Trace}

\paragraph{Analyze}

\paragraph{Extend and customize}

\section{Integration}
  \todo{integration}

  \subsection{Big Picture}
  \subsection{Usage}

\section{Implementation}
  \todo{implementation}

\subsection{Data Exchange}

\begin{itemize}
  \item Requirements
  \item YAML structured data
  \item BOAST --> MAQAO
  \item MAQAO --> BOAST
\end{itemize}

\subsection{Kernel generation}

\begin{itemize}
  \item Requirements
    \begin{itemize}
      \item Executable kernel
      \item No position-independent binary
      \item Dwarf debug info
    \end{itemize}
  \item Kernel wrapper
\end{itemize}

\subsection{Kernel instrumentation}

\begin{itemize}
  \item Principle
    \begin{itemize}
      \item Memory access asm instruction rewriting
    \end{itemize}
  \item Requirements
    \begin{itemize}
      \item System V ABI + ARM ABI compliance
    \end{itemize}
  \item ASM patching implementation
  \item Lua high-level instrumentation implementation
  \item MAQAO tracing library
\end{itemize}

\subsection{Kernel analysis framework}

\begin{itemize}
  \item Principle
  \item C low-level framework
  \item Lua high-level framework
  \item SIMD analyzer example
\end{itemize}

\section{Testcases examples}
  \todo{implementation}

  \subsection{Vector Addition}
\begin{itemize}
  \item Basic vector addition kernel
\end{itemize}

  \subsection{BigDFT Filter}
\begin{itemize}
  \item Mont-Blanc 2 Application BigDFT kernel
\end{itemize}

\section{Conclusion and Future Work}
\todo{conclusion}

\end{document}


% vim: set spell ft=tex fo=aw2t expandtab sw=2 tw=100:
